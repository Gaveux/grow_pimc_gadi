#!/usr/bin/python2
#=================================
# the dynamics module of Grow2.2
#=================================
# 
# note the separation of sampling runs from convergence runs
#
# to add other dynamics schemes (path integral monte carlo would
# be nice), add analogous if-blocks to the code below AND add
# to the list GrowState._dynamics in the state.py module

import os
import util
import shutil
import string

#=============================
# main function for sampling
#=============================
def do_dynamics(s):
  ' Function to call the appropriate executable to generate new geometries '
  print ' Sampling run... do_dynamics() using', s.Dyn_Sample
  if (s.Dyn_Sample == 'classical'):
    # clean up in advance
    util.Rmf('IN_TRAJ')
    util.Rmf('inic.small')
    util.Rmf('COUT')
    util.Rmf('TOUT')
    util.Rmf('TCON')
    util.Rmf('CON')
    # arrange input files 
    shutil.copy2('IN_TRAJ.small','IN_TRAJ')
    # initial conditions
    util.Run('trajstart > inic.small',s)
    # run trajectories
    util.Run('interptraj < inic.small',s)
    # copy summary of trajectory results to log file
    util.Run('cat OUT_SUMMARY',s)
    #
  elif (s.Dyn_Sample == 'qdmc'):
    # clean up in advance
    util.Rmf('IN_QDMC')
    util.Rmf('COUT')
    util.Rmf('TOUT')
    util.Rmf('TCON')
    util.Rmf('CON')
    util.Rmf('OUT_QDMC')
    # arrange input files 
    shutil.copy2('IN_QDMC.small','IN_QDMC')
#    shutil.copy2('IN_RESTART.1','IN_RESTART')
    # let the walkers go
    util.Run('qdmc90 1 > OUT_QDMC',s)
    # copy summary of results into log file
    util.Run(" grep 'ZPE (kJ' OUT_QDMC ",s)
    # copy the TOUT.1 file to TOUT for choosing
    shutil.copy2('TOUT.1','TOUT')
    # create a copy of all the output files
    n = str(s.Iter)
    shutil.copy2('fort.11', 'fort.11.' + n)
    shutil.copy2('OUT_QDMC', 'out_qdmc.' + n)
    shutil.copy2('TOUT', 'tout.' + n)
    shutil.copy2('OUT_BOND_HIST.1', 'out_bond_hist.' + n)
#    shutil.copy2('OUT_DIHED_HIST.1', 'out_dihed_hist.' + n)
    #

  #has been editted to work with the newer version of pimc.
  #the pimc input files are read in from the pimc.grow file
  #present in the running directory that specifies the
  #location and name of all the pimc inputs files and
  #specifies the output directory for the output files
  elif (s.Dyn_Sample == 'pimc'):
    # clean up in advance
    util.Rmf('COUT')
    util.Rmf('OUT_PIMC')
    util.Rmf('TOUT')
    util.Rmf('output/TOUT')
    # read input files and output directory from pimc.grow file
    infile_list = []
    with open('pimc.grow') as fp:
        counter = 1
        for line in fp:
            if counter < 8:
                infile_list.append(line.replace(' ',' '))
            elif counter == 8:
                out_dir = line.replace(' ',' ')
                #print 'output directory name',out_dir
            else:
                break
            counter=counter+1
        
    #comment out append .small to pimc.in file
    #infile_list[0]=infile_list[0]+'.small'
    # let the walkers go
    #run_string = 'pimc90 '
    #print 'infile_liest=',infile_list
    #for i in infile_list:
    #    run_string = run_string+' '+i+' '
    #run_string = run_string+' outdir > OUT_PIMC'
    #print 'pimc90 run_string =',run_string
    # hardwire in the filenames
    #run_string = 'pimc90 pimc.in system.in iseed.in binning.in IN_INTERP POT IN_ATOMPERMS outdir chk chk file > OUT_PIMC'
    run_string = 'pimc_O4_serial_grow pimc.in system.in iseed.in binning.in IN_INTERP POT IN_ATOMPERMS outdir chk chk file > OUT_PIMC'
    os.system(run_string)
    # copy summary of results into log file
    os.system(" grep 'Total average energy:' OUT_PIMC ")
    # copy the TOUT file to TOUT for choosing
    shutil.copy2('outdir/TOUT','TOUT')
    # create a copy of all the output files
    n = str(s.Iter)
    shutil.copy2('fort.11', 'fort.11.' + n)
    shutil.copy2('OUT_PIMC', 'outdir/out_pimc.' + n)
    shutil.copy2('TOUT', 'outdir/tout.' + n)
    #shutil.copy2('outdir/hist_out.bond', 'outdir/hist_out.bond.' + n)
    #shutil.copy2('outdir/hist_out.angle', 'outdir/hist_out.angle.' + n)
    #shutil.copy2('outdir/hist_out.dihedral', 'outdir/hist_out.dihedral.' + n)
    #
  elif (s.Dyn_Sample == 'fms90'):
    print ' Not yet implemented'
    # arrange input files
    # initial conditions?
    # spawn away
  else:
    # shouldn't be able to get here as s was validated in the grow module
    util.DieError('ChoiceError:',' dynamics for sampling = ' + s.Dyn_Sample,s)


#=========================================================================
# this function could be neater but the offsets are specific to the file 
# generated by choose, and this is only done once so there's no obvious
# need to write a function abstracting the grabbing of coordinates
# as is done for the ab initio output files
#=========================================================================

def do_choose(s):
  ' Function to run the choose program '
  print ' Choosing amongst sampled geometries'
  #chosen geometry saved as coords
  #reset coords as empty before we start
  coords=[]
  s.Chosen=[]
#-------------------------------------------------------------------------
# This is an old section of code where you choose either one rms or one
# hwt point per sampling iteration. The new method - arbitrary numbers of
# rms and hwt points per sampling iteration - is much more flexible
#-------------------------------------------------------------------------
#  if (s.PtsAdded == 0):
#    s.ChooseType = 'rms'
#  # run choose (either rms or hwt)
#  if (s.ChooseType == 'hwt'):
#    util.Run('choose2 < chooseHWt.inp ',s)
#  elif (s.ChooseType == 'rms'):
#    util.Run('choose2 < chooseRMS.inp ',s)
#  if (s.PtsAdded == 0):
#    s.Chosen=[]
#    # set choosetype to hwt after adding rms point
#    # it will reset to rms after resampling
#    s.ChooseType = 'hwt'
#  # grab the coordinates of the chosen geometries
#  fc = util.grab_contents('COUT',s)  
#  for line in range(0,len(fc)):
#    if (string.find(fc[line],' points to be added ') != -1):
#      coords=[]
#      line=line+2
#      while (fc[line] != ' \n'): # note newline separation assumed in COUT
#        coords.append(fc[line])  
#        line+=1
#      s.Chosen.append(coords)
#  # assumes only one rms point will be added after sampling.
#  # Also assumes rms point will be chosen first and the low energy
#  # point (if present) will be chosen with the RMS Point.
#  if ((len(s.Chosen) == 2) and (s.PtsAdded == 0)):
#    s.PtsChsn = s.rmsPts2add + s.hwtPts2add + 1
#  elif (s.PtsAdded == 0):
#    s.PtsChsn = s.rmsPts2add + s.hwtPts2add
#  # ensure these coordinates are saved
#  s.dump()
#--------------------------------------------------------------------------
  # write out number of rms points to choose (typically 1)
  print ' ... RMS choosing' 
  f=file('pts2add.inp','w')
  f.write(str(s.rmsPts2add)+'\n')
  f.close()
  # run choose (rms)
  if (s.rmsPts2add != 0):
    #util.Run('choose_pimc < chooseRMS.inp ',s)
    util.Run('choose < chooseRMS.inp ',s)
    # extract the chosen geometry/geometries from the output file
    print ' extracting RMS geometry'
    fc = util.grab_contents('COUT',s)
    s.Chosen=[]
    for line in range(0,len(fc)):
      if (string.find(fc[line],' points to be added ') != -1):
        coords=[]
        line=line+2
        while (fc[line] != ' \n'):
          coords.append(fc[line])
          line+=1
        s.Chosen.append(coords)

  # write out number of hwt points to choose (typically between 1 and 10)
  print ' ... HWt choosing'
  f=file('pts2add.inp','w')
  f.write(str(s.hwtPts2add)+'\n')
  f.close()
  # run choose (hwt)
  #util.Run('choose_pimc < chooseHWt.inp ',s)
  print ' ... running choose'
  util.Run('choose < chooseHWt.inp ',s)
  # extract the chosen geometry/geometries from the output file
  fc = util.grab_contents('COUT',s)
  for line in range(0,len(fc)):
    if (string.find(fc[line],' points to be added ') != -1):
      coords=[]
      line=line+2
      while (fc[line] != ' \n'):
        coords.append(fc[line])
        line+=1
      s.Chosen.append(coords)
  # ensure these coordinates are saved
  s.Pts2add = len(s.Chosen)
  s.PtsAdded = 0
  s.dump()

#============================================================================
# this is a separate function to allow convergence to be checked with a
# a method different from that used for sampling, e.g., when growing PES for 
# for FMS90 calculations we probably want to grow with classical trajectories
# and check convergence with a wavepacket calculation
#============================================================================

def do_convergence_check(s):
  ' Function to call the appropriate executable to calculate an\
 observable on the interpolated PES'
  print ' Convergence run... using ' + s.Dyn_Cvgce
  if (s.Dyn_Cvgce == 'classical'):
    # clean up in advance
    util.Rmf('IN_TRAJ')
    util.Rmf('inic.large')
    # arrange input files 
    shutil.copy2('IN_TRAJ.large','IN_TRAJ')
    # initial conditions
    util.Run('trajstart > inic.large',s)
    # run trajectories
    util.Run('interptraj < inic.large',s)
    # copy summary of trajectory results to log file
    util.Run('cat OUT_SUMMARY',s)
    # move output files to somewhere specific
    n = str(s.MaxIter/s.Iter)
    shutil.copy2('OUT_VEL', s.Molecule + '.vel.' + n)
    shutil.copy2('OUT_ANG', s.Molecule + '.ang.' + n)
    shutil.copy2('OUT_BTS', s.Molecule + '.bts.' + n)
    shutil.copy2('OUT_SUMMARY', s.Molecule + '.summary.' + n)
    shutil.copy2('OUT_FINALCV', s.Molecule + '.cv.' + n)
    shutil.copy2('OUT_IMPACTPAR', s.Molecule + '.impactpar.' + n)
    shutil.copy2('OUT_FINALBONDS', s.Molecule + '.bonds.' + n)
    shutil.copy2('inic.large', s.Molecule + '.inic.' + n)
    #
  elif (s.Dyn_Cvgce == 'qdmc'):
    # arrange input files
    util.Rmf('IN_QDMC')
    util.Rmf('COUT')
    util.Rmf('TOUT')
    util.Rmf('TCON')
    util.Rmf('CON')
    util.Rmf('OUT_QDMC')
    shutil.copy2('IN_QDMC.large', 'IN_QDMC')
    # let the walkers go
    util.Run('qdmc90 1 > OUT_QDMC',s)
    # copy summary of results into log file
    util.Run(" grep 'ZPE (kJ' OUT_QDMC ",s) 
    # copy the TOUT.1 file to TOUT for choosing
    shutil.copy2('TOUT.1','TOUT')
    # create a copy of output files
    n = str(s.MaxIter/s.Iter)
    shutil.copy2('OUT_QDMC', 'out_qdmc.conv.' + n)
    shutil.copy2('TOUT', 'tout.conv.' + n)
    shutil.copy2('OUT_BOND_HIST.1', 'out_bond_hist.conv.' + n)
#   shutil.copy2('OUT_DIHED_HIST.1', 'out_dihed_hist.conv.' + n)
    #
  
  #updated convergence check with pimc to work with the new version of the code
  elif (s.Dyn_Cvgce == 'pimc'):
    # read input files and output directory from pimc.grow file
    infile_list = []
    with open('pimc.grow') as fp:
        counter = 1
        for line in fp:
            if counter < 8:
                infile_list.append(line.replace(' ',' '))
            elif counter == 8:
                out_dir = line.replace(' ',' ')
            else:
                break
            counter=counter+1
        
    util.Rmf('outdir/TOUT')
    util.Rmf('OUT_PIMC')
    # let the walkers go
    #run_string = 'pimc90 '
    #for i in infile_list:
    #    run_string = run_string+i+' '
    #run_string = run_string+out_dir+'> OUT_PIMC'
    #hardwire in the run_string
    #run_string = 'pimc90 pimc.in system.in iseed.in binning.in IN_INTERP POT IN_ATOMPERMS outdir chk chk file > OUT_PIMC'
    run_string = 'pimc_grow pimc.in system.in iseed.in binning.in IN_INTERP POT IN_ATOMPERMS outdir chk chk file > OUT_PIMC'
    util.Run(run_string,s)
    # copy summary of results into log file
    os.system(" grep 'Total average energy:' OUT_PIMC ")
    # copy the outdir TOUT file to TOUT for choosing
    shutil.copy2('outdir/TOUT','TOUT')
    # create a copy of all the output files
    n = str(s.MaxIter/s.Iter)
    shutil.copy2('OUT_PIMC', 'outdir/out_pimc.conv.' + n)
    shutil.copy2('TOUT', 'outdir/tout.conv.' + n)
    #shutil.copy2('outdir/hist_out.bond', 'outdir/hist_out.conv.bond.' + n)
    #shutil.copy2('outdir/hist_out.angle', 'outdir/hist_out.conv.angle.' + n)

  elif (s.Dyn_Cvgce == 'fms90'):
    print ' Not yet implemented'
    # arrange input files
    # initial conditions?
    # spawn away
  else:
    # shouldn't be able to get here as s was validated in the grow module
    util.DieError('ChoiceError:',' dynamics for convergence = ' + s.Dyn_Cvgce,s)

